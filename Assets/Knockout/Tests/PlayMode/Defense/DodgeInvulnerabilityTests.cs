using System.Collections;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using Knockout.Characters.Components;
using Knockout.Characters.Data;
using Knockout.Combat;
using Knockout.Combat.States;
using Knockout.Combat.HitDetection;

namespace Knockout.Tests.PlayMode.Defense
{
    /// <summary>
    /// PlayMode integration tests for dodge i-frame invulnerability with hit detection.
    /// </summary>
    [TestFixture]
    public class DodgeInvulnerabilityTests
    {
        private GameObject _testCharacter;
        private CharacterHealth _health;
        private CombatStateMachine _stateMachine;
        private CharacterCombat _combat;
        private DodgeData _dodgeData;

        [SetUp]
        public void Setup()
        {
            // Create test character
            _testCharacter = new GameObject("TestCharacter");
            _combat = _testCharacter.AddComponent<CharacterCombat>();
            _health = _testCharacter.AddComponent<CharacterHealth>();
            _testCharacter.AddComponent<CharacterAnimator>();

            // Create test stats
            var stats = ScriptableObject.CreateInstance<CharacterStats>();
            var statsField = typeof(CharacterHealth).GetField("characterStats",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            statsField.SetValue(_health, stats);

            // Create and initialize state machine
            _stateMachine = new CombatStateMachine();
            _stateMachine.Initialize(_combat, new IdleState());

            var stateMachineField = typeof(CharacterHealth).GetField("_combatStateMachine",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            stateMachineField.SetValue(_health, _stateMachine);

            // Create dodge data
            _dodgeData = ScriptableObject.CreateInstance<DodgeData>();
        }

        [TearDown]
        public void TearDown()
        {
            Object.Destroy(_testCharacter);
            Object.Destroy(_dodgeData);
        }

        [UnityTest]
        public IEnumerator HitDetection_HitConnects_WhenNotDodging()
        {
            // Arrange
            float initialHealth = _health.CurrentHealth;
            var hitData = CreateTestHitData(20f);

            // Act
            _health.TakeDamage(hitData);
            yield return null;

            // Assert
            Assert.Less(_health.CurrentHealth, initialHealth, "Health should decrease when not dodging");
        }

        [UnityTest]
        public IEnumerator HitDetection_HitIgnored_DuringIFrameWindow()
        {
            // Arrange
            DodgingState dodgingState = new DodgingState();
            dodgingState.Enter(_combat, DodgeDirection.Left, _dodgeData);

            // Advance to i-frame window
            for (int i = 0; i < 5; i++)
            {
                dodgingState.Update(_combat);
            }

            _stateMachine.ChangeState(dodgingState);

            float initialHealth = _health.CurrentHealth;
            var hitData = CreateTestHitData(20f);

            // Act
            _health.TakeDamage(hitData);
            yield return null;

            // Assert
            Assert.AreEqual(initialHealth, _health.CurrentHealth,
                "Health should not change during i-frame window");
        }

        [UnityTest]
        public IEnumerator HitDetection_HitConnects_DuringDodgeRecovery()
        {
            // Arrange
            DodgingState dodgingState = new DodgingState();
            dodgingState.Enter(_combat, DodgeDirection.Left, _dodgeData);

            // Advance past i-frame window (into recovery)
            for (int i = 0; i < 15; i++)
            {
                dodgingState.Update(_combat);
            }

            _stateMachine.ChangeState(dodgingState);

            float initialHealth = _health.CurrentHealth;
            var hitData = CreateTestHitData(20f);

            // Act
            _health.TakeDamage(hitData);
            yield return null;

            // Assert
            Assert.Less(_health.CurrentHealth, initialHealth,
                "Health should decrease during dodge recovery (outside i-frames)");
        }

        [UnityTest]
        public IEnumerator HitDetection_OnHitDodged_EventFires()
        {
            // Arrange
            bool eventFired = false;
            HitData capturedHitData = default;

            _health.OnHitDodged += (hitData) =>
            {
                eventFired = true;
                capturedHitData = hitData;
            };

            DodgingState dodgingState = new DodgingState();
            dodgingState.Enter(_combat, DodgeDirection.Left, _dodgeData);

            // Advance to i-frame window
            for (int i = 0; i < 5; i++)
            {
                dodgingState.Update(_combat);
            }

            _stateMachine.ChangeState(dodgingState);

            var hitData = CreateTestHitData(20f);

            // Act
            _health.TakeDamage(hitData);
            yield return null;

            // Assert
            Assert.IsTrue(eventFired, "OnHitDodged event should fire when hit dodged");
            Assert.AreEqual(20f, capturedHitData.Damage, "Event should pass correct hit data");
        }

        private HitData CreateTestHitData(float damage)
        {
            return new HitData(
                attacker: _testCharacter,
                damage: damage,
                knockback: 0f,
                hitPoint: Vector3.zero,
                hitDirection: Vector3.forward,
                hitType: 0,
                attackName: "TestAttack"
            );
        }
    }
}
